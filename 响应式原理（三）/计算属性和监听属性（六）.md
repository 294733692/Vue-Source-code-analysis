### 计算属性（computed）和监听属性（watch）

####  计算属性（computed）

`computed`属性初始化是发生在`Vue`实例初始化阶段的`initState`函数中，

```typescript
export function initState (vm: Component) {
  // ...  
  // 如果存在计算属性，就初始化
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

这里执行了这么一段代码`if (opts.computed) initComputed(vm, opts.computed)`，这里`initComputed`函数是关键，函数定义在

> src/core/instance/state.js

```typescript
const computedWatcherOptions = { computed: true }
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  // vm._computedWatchers创建为一个空对象  
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  // 是否为服务器渲染
  const isSSR = isServerRendering()
		
  for (const key in computed) {
    // 获取用户在computed中定义的方法或参数
    // 获取到computed中的每个userDef  
    const userDef = computed[key]
    // 判断userDef是否是方法，是就返回userDef，不是就尝试获取userDef的getter函数
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    // 如果拿不到getter方法，就在开发环境报错提示
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }
	
    // 如果不是在ssr环境下  
    if (!isSSR) {
      // create internal watcher for the computed property.
      // 创建watcher，对应到watchers[key]
      // 这里的watcher和渲染Watcher不一样，这里的Watcher是computed Watcher  
      watchers[key] = new Watcher(
        vm, // vm实例
        getter || noop, // getter函数或者是 noop方法
        noop,
        computedWatcherOptions // 这里为true，区别渲染Watcher
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    // 如果key不在vm实例当中，  
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      // 如果key在vm中了，那么说明在data或者props中已经定义过了  
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}
```

这里首次创建了`watchers `和`vm._computedWatchers`为空对象然后判断当前环境是否是`SSR`环境，接下来遍历`computed`

```js
for (const key in computed) {
    // 获取用户在computed中定义的方法或参数
    // 获取到computed中的每个userDef  
    const userDef = computed[key]
    // 判断userDef是否是方法，是就返回userDef，不是就尝试获取userDef的getter函数
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    // 如果拿不到getter方法，就在开发环境报错提示
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }
```

这里遍历`computed`尝试拿到`userDef`对应的`getter`函数，如果`getter`不存在，就在开发环境报错

，接下来

```js
    // 如果不是在ssr环境下  
    if (!isSSR) {
      // create internal watcher for the computed property.
      // 创建watcher，对应到watchers[key]
      // 这里的watcher和渲染Watcher不一样，这里的Watcher是computed Watcher  
      watchers[key] = new Watcher(
        vm, // vm实例
        getter || noop, // getter函数或者是 noop为回调方法
        noop,
        computedWatcherOptions // 这里为true，区别渲染Watcher
      )
    }
```

这里如果不是在`SSR`环境下，创建一个`watcher[key]`，需要注意的是，这里的`Watcher`和渲染`Watcher`不一样，我们看到这里传入了一个参数`computedWatcherOptions`，这个参数为`true`，是`computed Watcher`。最后

```js
if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      // 如果key在vm中了，那么说明在data或者props中已经定义过了  
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
```

最后对用户在`computed`中定义的属性进行判断，如果`key`不是`vm`的属性，就调用`defineComputed`方法，如果是`vm`的属性，那么判断`key`是否是在`data`或是`props`中已经定义过了。如果是，那么就在开发环境报错。



接下来看看`defineComputed`函数的实现

```typescript
export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  // 判断是否为ssr环境  
  const shouldCache = !isServerRendering()
  // 判断userDef是否为方法
  if (typeof userDef === 'function') {
    // 如果是不是ssr环境，将  createComputedGetter(key)的返回值赋值给 sharedPropertyDefinition.get
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property "${key}" was assigned to but it has no setter.`,
        this
      )
    }
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

这块逻辑其实挺简单啊就是利用`Object.defineProperty`给计算属性对应的`key`值添加`getter`和`setter`属性，`setter`通常是一个计算属性的对象，但是拥有`set`方法的时候才会有，否则`setter`就是一个空函数，这里我们关注`getter`的时候。来看看`createComputedGetter()`函数

```js
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      watcher.depend()
      return watcher.evaluate()
    }
  }
}
```

`createComputedGetter`函数返回了`computedGetter`函数，它就是计算属性对应的`getter`