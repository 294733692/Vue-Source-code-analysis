### 异步组件

在平时开发的过程中，我们为了减少首屏代码的体积，往往会把一些非首屏的组件设计成异步组件的形式，按需加载。

下面是Vue对异步组件的介绍

> ​	[Vue异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件)

在大型应用中，我们可能需要将应用分隔成小一些的代码块，并且只在需要的时候才从服务器加载过来一个模块。为了简化，Vue允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue只有在这个组件需要被渲染的时候才会触发工厂函数，并且会把结果缓存存储起来，以便未来从重渲染。

```js
Vue.component('async-example', function (resolve, reject) {
    setTimeout(function() {
        // 向'resolve'回调传递组件定义
        resolve({
            template: '<div>I am async</div>'
        })
    }, 1000)
})
```

从这里例子上我们可以看到，Vue注册的组件不在时一个对象，而是一个工厂函数，函数有两个参数，`resolve`和`reject`，函数内部通过调用`setTimeout`模拟异步，实际使用可能通过参数动态请求异步组件的JS地址，最终通过执行`resolve`方法，它的参数就是我们的异步组件对象。当然，也可以使用`reject(reason)`函数，来表示加载失败。官方推荐的做法是将异步组件和[webpack的code-splitting](https://webpack.js.org/guides/code-splitting/)一起配合使用。下面是例子：

### 普通异步组件

```js
Vue.component('async-webpack-example', function() {
    // 这个特殊的`require`语法将会告诉webpack
    // 自动将你的构建代码拆分成多个包
    // 会通过Ajax请求加载
    require(['./my-async-component'], resolve)
})
```

### Promise异步组件

我们也可以在工厂函数中返回`Promise`，所以把webpack和ES2015语法结合在一起。

```js
Vue.component(
    'async-webpack-example',
	// 这个'import'函数会返回一个`Promise`对象  
    () => import('./my-async-component')
)
```

我们在局部注册的时候，也可以直接提供一个返回的`Promise`函数: 

```js
new Vue({
    // ...
    components: {
        'my-component': ()=>import ('./my-async-component')
    }
})
```

上面说了异步组件的使用方式，接下来从源码分析异步组件的注册实现过程。

在[组件注册](https://github.com/294733692/Vue-Source-code-analysis/blob/master/组件化（二）/组件注册（五）.md)这里我们分析了组件的注册过程，由于异步异步组件的定义并不是一个普通对象，所有不会执行`Vue.extend`的逻辑（把它变成一个组件的构造函数)，但是它仍然可以执行`createComponent`函数，我们来看下这个函数，该函数定义在

> src/core/vdom/create-component.js

```typescript
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }

  // ...

  // async component
  let asyncFactory
  // 判断cid是否为空，是空，说明为异步组件。
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }
}
```

这里省略了其他不相关的代码，只保留了异步组件相关的逻辑，由于我们这个时候传入的`Ctor`是一个函数，那么它并不会执行`Vue.extend`逻辑，因此它的`cid`是`undefined`，进入到异步组件的创建逻辑。这里首先执行了`Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)`方法，`resolveAsyncComponent`方法定义在

> src/code/cdom/helpers/resolve-async-components.js

```typescript
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>,
  context: Component
): Class<Component> | void {
  // 这里是对高级异步组件的判断  
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }
    
  // 考虑到可能会出现多个地方同时初始化同一个组件，那么它的实际加载应该只有一次，	
  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context)
  } else {
    const contexts = factory.contexts = [context]
    let sync = true

    const forceRender = () => {
      for (let i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate()
      }
    }
	
    // 这里的resolve和reject被once函数包装，
    // 主要为了保证resolve和reject只执行一次
    const resolve = once((res: Object | Class<Component>) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender()
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender()
      }
    })

    const res = factory(resolve, reject)

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            setTimeout(() => {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender()
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(() => {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

`resolveAsyncComponent`函数，在内部实际上处理了3总异步组件的创建方式。除了`普通异步组件`、`Promise异步组件`之外，还有一种`高级异步组件`

```js
const AsyncComponent = () => ({
    // 需要加载的组件（应该是一个`Promise`对象）
    component: import('./MyComponent.vue'),
    // 异步组件加载时使用的组件
    loading: LoadingComponent,
    // 加载失败使用的组件
    error: ErrorComponent,
    // 展示加载时组件的延时时间。默认值是200毫秒
    delay: 200,
    // 如果提供了超时时间且组件加载超时 
    // 则使用加载失败时使用的组件。默认值是：`Infinity`,
    timeout: 3000
})
```



### 普通异步组件函数

针对普通函数的情况，前面的几个if判断可以忽略，他们是对高级异步组件的判断，对于`factory.contexts`判断，是考虑到有可能多个地方同时初始化同一个异步组件，那么它的实际加载应该只有一次。接着按照实际的加载逻辑，定义了`forceRender`、`resolve`和`reject`函数，需要注意的是：`resolve`和`reject`函数都是用`once`函数做了一层包装。

`once`函数定义在

> ​	src/shared/util.js

```typescript
/**
 * Ensure a function is called only once.
 */
export function once (fn: Function): Function {
  let called = false
  return function () {
    if (!called) {
      called = true
      fn.apply(this, arguments)
    }
  }
}
```

`once`函数逻辑很简单，只是简单的传入了一个函数，并返回一个新函数，利用了闭包和一个标志位保证了它包装后的函数只执行一次，也就是说使用`once`包装了`resovle`和`reject`函数，确保了`resolve`和`reject`函数只能执行一次。

`resolve`函数最后判断了`async`，在现在这个场景下的`async`明显为`false`，那么就会执行`forceRender`函数，它会遍历`factory.contexts`，拿到每一个调用异步组件的实例`vm`，执行`vm.$forceUpdate()`方法，`vm.$forceUpdate()`方法定义在

> src/code/instance/lifecycle.js

```typescript
Vue.prototype.$forceUpdate = function () {
  const vm: Component = this
  if (vm._watcher) {
    vm._watcher.update()
  }
}
```

这段代码就是调用渲染`watcher`的`update`方法，让渲染`watcher`对应的回调函数执行，也就是触发了组件的重新渲染。之所以这么做是因为Vue通过是数据驱动视图重新渲染，但是在整个异步组件加载过程中是没有发生数据变化的，所以通过`$forceUpdate`可以强制组件重新渲染一次。

### Promise异步组件

```js
Vue.component(
  'async-webpack-example',
  // 该 `import` 函数返回一个 `Promise` 对象。
  () => import('./my-async-component')
)
```

**webpack 2+**支持异步加载的语法糖：`() => import('./my-async-component')`，当执行完`res = factory(resolve, reject)`，返回的值就是`import ('./my-async-component')`的返回值，它就是一个`Promise`对象，接着进入if条件，有判断了`typeof res.then === 'function'`，满足条件执行下面这段代码：

```js
if (isUndef(factory.resolved)) {
    res.then(resolve, reject)
}
```

当组件异步加载成功后，执行`resolve`，加载失败执行`reject`，这样就配合了**`webpack 2+`**的异步加载组件方式(`Promise`)加载异步组件。