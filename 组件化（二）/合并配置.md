### 合并配置

`new Vue`的过程中，合并配置通常有两个场景

- 一个是外部我们的代码主动调用`new Vue(options)`的方式实例化一个对象。
- 另外一个是组件内部过程中通过`new Vue(options)`实例化子组件。

但是无论是哪一种场景，都是会执行实例的`_init(option)`，它首先会执行一个`mergeOptions`的逻辑，相关代码在

> src/core/instance/init.js

```typescript
Vue.prototype._init = function (options?: Object) {
  // merge options
  if (options && options._isComponent) {
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      // 解决全局mixin  
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
}
```

这里可以明显的看到，两种场景对于`options`合并逻辑是不一样的，并且对于传递的参数大不相同。

举一个粒子：

```vue
import Vue from 'vue'

let childComponent = {
	template: `<div>{{msg}}</div>`,
	created(){
		console.log("child created")
	},
	mounted() {
		console.log('child mounted')
	},
	data(){
		return {
			msg: 'merge options i.e'
		}
	}
}
//全局混入
Vue.minix ({
	created(){
		console.log('parent created')
	}
})
let app = new Vue({
  el: '#app',
  render: h => h(childComp)
})
```



###  外部场景

当执行`new Vue`的时候，在执行`this._init(options)`的时候，就会执行如下逻辑去合并`options`

```typescript
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

这里通过调用`mergeOptions`方法来进行合并，实际上就是把`resolveConstructorOptions`的返回值和`options`做了合并，`resolveConstructorOptions`暂时不考虑实现过程，在外部场景下，它还是简单返回了`vm.construtor.options`，相当于返回`Vue.options`，这个值是在`initGlobalAPI(Vue)`的时候定义的。

> src/core/global-api/index.js

下面值截取了相关的代码

```typescript
export function initGlobalAPI (Vue: GlobalAPI) {
  // ...
  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue

  extend(Vue.options.components, builtInComponents)
  // ...
}
```

这里开始通过`Vue.options = object.create(null)`创建了一个空对象，然后遍历`ASSET_TYPES`，`ASSET_TYPES`的定义在

> src/shared/constants.js

```typescript
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]
```

上面的遍历过后的代码相当于

```typescript
Vue.options.components = {}
Vue.options.directives = {}
Vue.options.filters = {}
```

接着执行了`Vue.options._base = Vue`代码。这块逻辑可以看看[createComponent(组件VNode创建的过程)(一)]([https://github.com/294733692/Vue-Source-code-analysis/blob/master/%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/createComponent(%E7%BB%84%E4%BB%B6VNode%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B)(%E4%B8%80).md](https://github.com/294733692/Vue-Source-code-analysis/blob/master/组件化（二）/createComponent(组件VNode创建的过程)(一).md)

。

最后通过`extend(Vue.options.components, builtInComponents)`把一些内置组件扩展到`Vue.options.components`上，Vue的内置组件目前有`<keep-alive></keep-alive>`、`<transition></transition>`、`<transition-group></transition-group>`组件，这也就是为什么我们在Vue文件中，不需要注册就可以直接使用的原因。

来看`mergeOptions`函数，定义在

> src/core/util/options.js

```typescript
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    // 组件定义检测
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)
  const extendsFrom = child.extends
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm)
  }
  if (child.mixins) {
    for (let i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm)
    }
  }
  const options = {}
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    // 这里的strats实际是一个合并策略集合，通过strats[key]去strats去取相应的函数，如果不存在，就取默认的strat
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

`mergeOption`的主要功能就是把`parent`和`child`两个对象根据一些合并策略，合并成一个新的对象返回。

核心的几步

- 先递归把`extends`和`mixins`合并到`parent`上
- 然后遍历`parent`，调用`mergeField`，
- 然后再遍历`child`，如果`parent`自身的属性上没有`key`，那么调用`mergeField`方法

需要注意的是，这里的`mergeField`函数，对于不同的`key`有着不同的合并策略，举个栗子，声明周期函数，它的合并策略是这样的。

```typescript
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook
})
```

其中`LIFECTCLE_HOOKS`定义在

> src/shared/constants.js

```typescript
export const LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
]
```

这里定义了Vue所有的钩子函数的名称，所有对钩子函数，他们的合并策略是`mergeHook`函数。这里使用了多层次的三元运算符。逻辑是：

- 如果不存在`childVal`，就返回`parentVal`；
- 接下来判断是否存在`parentVal`，如果存在就把`childVal`添加到`parentVal`中，并返回新的数组。否则返回`childVal`的数组。

回到`mergeOptions`函数，一旦`parent`和`child`都定义了相同的钩子函数，那么它会把两个钩子函数合并成一个数组。

通过执行`mergeField`函数，把合并的结果保存到`options`对象中，最后返回它。最后在我们举的例中，会经过下面这段代码：

```typescript
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

最后的`vm.$options`的值差不多是这样的

```vue
vm.$options = {
	components: {},
	created:[
		function created() {
			console.log('parent created')
		}
	],
	directives: {},
	filters: {},
	_base: function Vue(options) {
		// ...
	},
	el: "#app",
	render: h => h
}
```



其他属性的合并策略定义在：

> src/core/util/options.js

